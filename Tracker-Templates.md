## The Tracker template JSON
The tracker template is used to provide the configuration that the uploader should use to upload a torrent to a particular tracker. Each tracker irrespective of the platform its based on will have some differences. To accommodate for these differences the site template json is introduced. How the template is used is explained below. For now lets get to know the various components of this template file



### :large_blue_diamond: Simple Attributes
The simple attributes are pretty self explanatory.
| Key| Description|
| ------ | ------ |
| **name**| The name of the tracker|
| **url**| The url for the tracker home page|
| **platform**| The codebase / platform used by the tracker [UNIT3D, Gazelle, XBTIT, etc]|
| **source**| The value of the `source` filed to be added to the info dictionary of the torrent metadata|
| **bbcode_line_break**| The line break to be used in bbcode data|
| **bbcode_code**| The `code` tags accepted by the tracker bbcode parser|
| **title_separator**| The separator to be used to create the torrent title [{space} or {dot} or {anything else you need}]|
| **torrents_search**| The url to be used to search for existing torrents in the tracker [checking for duplicates]|
| **upload_form**| The url to be used to upload the torrent to the tracker|

<details><summary>Sample Data For Reference</summary>

    "name": "Tracker",
    "url": "https://tracker.io/",
    "platform": "TBDev",
    "source": "TKR",
    "bbcode_line_break": "\n",
    "bbcode_code": "[code][/code]",
    "title_separator" : ".",
    "torrents_search": "https://tracker.io/api/torrent",
    "upload_form": "https://tracker.io/api/upload",

</details>



### :large_blue_diamond: Technical Jargons
These technical jargons denote the different methods that needs to be used to interact with the tracker.
| Key| Description| Supported Values|
| ------ | ------ | ------ |
| **authentication_mode**| The type of authentication method to be used. | API_KEY \| BEARER|
| **payload_type**| The structure of the payload that is accepted by the tracker| MULTI-PART \| JSON|

<details><summary>Sample Data For Reference</summary>

    "technical_jargons": {
        "authentication_mode": "BEARER",
        "payload_type": "JSON"
    },

</details>

#### Technical Jargons Explanation

1. **API_KEY** : When API_KEY authentication mode is used, an api_key needs to be provided by the user which will be used to authenticate the user. The placeholder {api_key} can be used to denote the place where api key should be substituted by the uploader.

```
Assume the API_KEY = asd12indkasnd19i2ndo1nci2n3ueqj
Upload URL Configured: https://tracker.me/api/upload/{api_key}
Translated URL: https://tracker.me/api/upload/asd12indkasnd19i2ndo1nci2n3ueqj
```

2. **BEARER** : If authentication mode is set as BEARER, the api key provided via the `config.env` will be set as the Bearer Token in the Authorization Header during communication with the tracker.
```
Assume the API_KEY = asd12indkasnd19i2ndo1nci2n3ueqj
Upload URL Configured: https://tracker.me/api/upload/
During communication the following header will be added to each request. [ Authorization: Bearer asd12indkasnd19i2ndo1nci2n3ueqj]
```

3. **JSON** : If JSON is provided as the payload type, the uploader will send the upload payload in JSON format. Please note that in cases where JSON is accepted the files [nfos and torrents] needs to be encoded as base64 strings.

4. **MULTI-PART** : If MULTI-PARTis provided as the payload type, the uploader will send the upload payload as multi-part form data. Any files will be send to the endpoint as FILES



### :large_blue_diamond: Translation Attributes
The translation attributes provides the mapping for the `name/key` used by us to the keys that are recognizable by the target tracker. For example the .torrent file is named as `dot_torrent` inside the uploader. For some trackers the .torrent file might be read from the key `file`, for some trackers it might be `torrent`. Any data that the uploader collects which must be sent to the tracker can be mapped / translated here.
| Key| Description|
| ------ | ------ |
| **dot_torrent**| The dot torrent file|
| **nfo_file**| The .nfo file|
| **torrent_title**| The title of the torrent created by the uploader according to the Torrent Title Format|
| **description**| The description generated by the uploader [#]|
| **mediainfo**| The mediainfo output [!]|
| **bdinfo**| The quick summary of bdinfo parsing output [!]|
| **type**| The type of the upload. **[movie or episode]** |
| **source**| The source of the input file **[BluRay, WEB, HDTV, etc]** |
| **resolution**| The resolution of the input file **[2160p, 1080p, etc]** |
| **tmdb**| The TMDB id|
| **imdb**| The IMDB id|
| **tvdb**| The TVDB id|
| **mal**| The MAL id|
| **igdb**| The IGDB id|
| **anon**| Denotes whether to upload the torrent anonymously or not|
| **live**| When to make the upload live or upload as a draft [*]|
| **sd**| Denotes whether the upload is an SD upload|
| **optimized**| Denotes whether the upload is a stream optimized upload|
| **internal**| [Internal] Indicates whether the upload is an internal upload |
| **featured**| [Internal] Indicates whether the upload should be featured|
| **doubleup**| [Internal] Indicates whether the upload should be granted double upload|
| **tripleup**| [Internal] Indicates whether the upload should be granted triple upload [##]|
| **sticky**| [Internal] Indicates whether the upload should be marked as sticky|
| **freeleech**| [Internal] Indicates whether the upload should be made freeleech |
| **url_images**| The screenshot urls as a list|
| **hybrid_type **| The hybrid type mapping that can be created from `type, source and resolution` [^] |
| **shameless_self_promotion**| Do i really need to explain this?|

> [#] : This is the screenshots as thumbnail linked bbcode and the shameless self promotion. <br>
[!] : Only one of `bdinfo` and `mediainfo` will be sent. The decision is made based on the `-disc` argument. [Whether upload is a Full Disk or not]<br>
[Internal] : Can be used only by certain internal members of the target tracker
[*] : Currently supported only for BHD<br>
[##] : Supported only on TSP<br>
[^] : See the Hybrid Type Mapping for more details

<details><summary>Sample configuration for reference</summary>

    "translation": {
        "dot_torrent": "torrent",
        "nfo_file": "nfo",
        "torrent_title": "name",
        "description": "description",
        "mediainfo": "mediainfo",
        "bdinfo": "bdinfo",
        "type": "type_id",
        "source": "source_id",
        "resolution": "resolution_id",
        "shameless_self_promotion": "release_notes",
        "url_images": "screenshots",
        "hybrid_type": "category",
        "tmdb": "tmdb",
        "imdb": "imdb",
        "tvdb": "tvdb",
        "mal": "mal",
        "igdb": "igdb",
        "anon": "anonymous",
        "live": "publish",
        "sd": "low_definition",
        "optimized": "stream_optimized",
        "internal": "internal",
        "featured": "featured",
        "doubleup": "doubleup",
        "tripleup": "tripleup",
        "sticky": "sticky",
        "freeleech": "free"
    }

</details>

## How exactly `/site_templates/*.json` works
1. Each site is going to have some small differences in the required API key/values as well as what info we can pass in
    * A simple example of this would be the *resolution / source*  sites have you select
    * BHD has `BD Remux` clumped in with other resolutions (??) while still leaving `Bluray` as a `source` option

2. So `site_templates/` purpose is to set our own standard and translate other sites to our style
    * The most obvious example of this is the `translation` dict which matches our info 'name/key' to each site, this can be seen below
    *
        ```
        "translation": {
            "dot_torrent": "file",
            "torrent_title" : "name",
            "description": "description",
            "mediainfo": "mediainfo",
            "bdinfo": "bdinfo",
            "shameless_self_promotion": "releaseInfo",
            "url_images": "screenshots",
            "hybrid_type": "hybrid_type",
            "type": "category_id",
            "source": "source",
            "resolution": "type",
            "tmdb": "tmdb_id",
            "imdb": "imdb_id",
            "anon": "anon",
            "live": "live",
            "sd": "sd",
            "tvdb": "tvdb",
            "mal": "mal",
            "igdb": "igdb",
            "optimized": "stream",
            "nfo_file": "nfo_file"
        },
        ```
    * In the example above ^^ we convert our `torrent_info` dict to fit into BHDs API parameters
        * e.g. in the script we assign `dot_torrent` to the path of the generated .torrent file 
            * BHD want it passed as `file`
            * BLU & ACM want it passed as `torrent`
3.  Next we split the **.json* file into **2** parts
    * **Part 1:** Required
        * All the *Keys* here **have** to be set a value and passed during the upload process
        * If the value is doesn't exist, we just the value to `0` but it still has to be passed
            * e.g. the TVDB ID for a movie doesn't exist, but we still pass it with the value `0`
    * **Part 2:** Optional
        * This currently only really applies to BHD (Could change in future)
        * BHD has optional fields that can be assigned to torrents such as:
            * `edition` `region` `pack` `special` `sd` etc
        * None of these are typically *required* when uploading but its good tracker etiquette to be as accurate & complete as possible when uploading

4. When `auto_upload.py` runs, one of the last things we do is format all the data we have into the required API parameters
    * **The Process:**
    * 1\. We start a loop for every item under `required` in the corresponding `/site_templates/*.json` file
    * 2\. Using the `translation` dict we reverse each required API param into the formatting we use
    * 3\. We try to match each API param (reversed) to key/values in the `torrent_info` dict
    * 4\. If we get match we assign the value of `torrent_info[API_PARAM_REVERSED]` into a new dict called `tracker_settings`
    * 5\. In the case of no match we just assign a value of `0` 
        * Remember these are **Required** keys so each one must have a value (e.g. `0`)


5. **Resolution** & **Source**:  
    **NOTE:** These *definitions* will be different for each site
    * These are a bit tricky since we need to define what a particular source is & what its requirements are
        * e.g. BHD source:`BD Remux` must have a *Bluray* source, Be a *Remux*, & be *1080p*
    * See the following example:
      ```
      # 0 = optional
      # 1 = required
      # 2 = one of these items must 'match'

      
      "UHD Remux": {
        "bluray_remux": 1,
        "2160p": 1
      },
      
      "2160p": {
        "2160p": 1,
        "bluray_encode": 2,
        "webdl": 2,
        "webrip" : 2
      },
      ```
    * In this example ^^ 
      * `UHD Remux` requires that both `bluray_remux` & `2160p` be in the `torrent_info` dict
        * if either `bluray_remux` or `2160p` is missing then it's not considered a match and we try the next *definition*
      * `2160p` requires that `2160p` be in the `torrent_info` dict & **1** of the following:
        * `bluray_encode`, `webdl`, or `webrip`
